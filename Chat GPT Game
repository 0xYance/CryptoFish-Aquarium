<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Cryptofish Pixel Aquarium</title>
  <style>
    :root{
      --bg:#0b1020;        /* deep ocean */
      --panel:#121a33;     /* UI panel */
      --ink:#cdd7ff;       /* text */
      --ink-dim:#8ca0ff;   /* muted */
      --accent:#64ffd1;    /* aqua */
      --danger:#ff6b6b;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font:14px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    .wrap{display:grid;grid-template-rows:auto auto 1fr; height:100%;}
    header{display:flex;gap:12px;align-items:center;padding:10px 12px;background:linear-gradient(180deg,#0c1532,#0a0f24)}
    header h1{font-size:16px;margin:0;font-weight:700;letter-spacing:.3px}
    header .dot{width:10px;height:10px;border-radius:50%;background:var(--accent);box-shadow:0 0 12px var(--accent)}
    header .spacer{flex:1}
    header button{background:#0c1a3a;color:var(--ink);border:1px solid rgba(255,255,255,.1);border-radius:10px;padding:6px 10px;cursor:pointer}

    .panel{display:flex;gap:12px;flex-wrap:wrap;padding:10px;background:var(--panel);border-bottom:1px solid rgba(255,255,255,.07)}
    .group{display:flex;flex-direction:column;gap:6px;min-width:210px}
    label{font-size:12px;color:var(--ink-dim)}
    input,textarea,select{background:#0b1330;color:var(--ink);border:1px solid rgba(255,255,255,.08);border-radius:10px;padding:8px 10px;outline:none}
    textarea{min-height:38px;resize:vertical}
    button{background:#0c1a3a;color:var(--ink);border:1px solid rgba(255,255,255,.1);border-radius:12px;padding:8px 12px;cursor:pointer}
    button:hover{border-color:rgba(255,255,255,.25)}
    .primary{background:linear-gradient(180deg,#17336b,#122650);border-color:#355dff;box-shadow:0 0 0 2px rgba(53,93,255,.15) inset}
    .danger{background:#2a0f16;border-color:#6b1a26;color:#ffd1d1}
    .muted{opacity:.8}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .sep{height:1px;background:rgba(255,255,255,.06);margin:6px 0}

    #stage{position:relative;flex:1;min-height:520px}
    canvas{position:absolute;inset:0; width:100%; height:100%; image-rendering: pixelated;}
    .hud{position:absolute;left:10px;bottom:10px;background:rgba(0,0,0,.35);backdrop-filter: blur(6px); padding:8px 10px;border-radius:10px;font-size:12px}
    .pill{display:inline-flex;align-items:center;gap:6px;border:1px solid rgba(255,255,255,.1);padding:4px 8px;border-radius:999px}
    .stat{color:var(--ink-dim)}
    .link{color:var(--accent);text-decoration:none}
    #testOut{white-space:pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background:#0b1330; border:1px solid rgba(255,255,255,.08); border-radius:10px; padding:8px;}

    /* floating reopen button when panel hidden */
    #menuFab{position:fixed; top:10px; right:10px; z-index:20; display:none; background:#0c1a3a; border:1px solid rgba(255,255,255,.15); border-radius:10px; padding:8px 10px}
  </style>
  <!-- Ethers v5 for ERC-721 tokenURI lookups on Ethereum mainnet -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.min.js"></script>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="dot"></div>
      <h1>Cryptofish Pixel Aquarium</h1>
      <div class="stat" id="status">ready</div>
      <div class="spacer"></div>
      <button id="fsBtn" title="Toggle Fullscreen (F)">Fullscreen</button>
      <button id="toggleMenu" title="Hide/Show menu (M)">Hide Menu</button>
    </header>

    <div class="panel" id="panel">
      <div class="group" style="min-width:320px">
        <label>Ethereum Contract (ERC-721)</label>
        <input id="contract" value="0x9ef31ce8cca614e7aff3c1b883740e8d2728fe91"/>
        <small class="stat">Default is <span title="Cryptofish collection contract on Ethereum">Cryptofish</span>.</small>
      </div>

      <div class="group" style="flex:1;min-width:320px">
        <label>Token IDs (comma or space separated, up to 20)</label>
        <textarea id="ids" placeholder="e.g. 12, 34, 56"></textarea>
        <div class="row">
          <button class="primary" id="addByIds">Add fish by NFT IDs</button>
          <button id="clear">Clear all</button>
          <button id="pause">Pause</button>
          <label class="row" style="gap:6px"><input type="checkbox" id="staticToggle"/> Static (no swim)</label>
        </div>
      </div>

      <div class="group" style="min-width:320px">
        <label>Image URL (optional alternative to NFT ID)</label>
        <input id="imgUrl" placeholder="https://... (ipfs:// also works)"/>
        <div class="row">
          <button id="addByUrl">Add fish by URL</button>
          <button id="shot">Export PNG</button>
        </div>
      </div>

      <div class="group" style="min-width:320px">
        <label>Local image file (best for CORS issues)</label>
        <input id="fileInput" type="file" accept="image/*" multiple />
        <div class="row">
          <label class="row" style="gap:6px"><input type="checkbox" id="useProxy" checked/> Auto CORS fix for URLs</label>
          <button id="runTests">Run tests</button>
        </div>
        <small class="stat">Tip: You can also drag & drop images directly onto the aquarium.</small>
        <div id="testOut" class="stat"></div>
      </div>

      <div class="group" style="min-width:220px">
        <label>Background removal threshold <span id="threshOut" class="stat"></span></label>
        <input id="thresh" type="range" min="10" max="80" value="36" />
        <small class="stat">Automatically removes a solid background by sampling the image borders.</small>
      </div>

      <div class="group" style="min-width:220px">
        <label>Pixel size <span id="pxOut" class="stat"></span></label>
        <input id="px" type="range" min="2" max="16" value="8" />
        <small class="stat">Aquarium pixels. Larger = chunkier retro look.</small>
      </div>

      <div class="group" style="min-width:220px">
        <label>Swim speed <span id="spdOut" class="stat"></span></label>
        <input id="spd" type="range" min="50" max="200" value="120" />
        <small class="stat">Affects newly added fish. Toggle Static to freeze.</small>
      </div>

      <div class="group" style="min-width:220px">
        <label>Fish size (new) <span id="sizeOut" class="stat"></span></label>
        <input id="size" type="range" min="5" max="80" value="30" />
        <div class="row">
          <button id="resizeAll">Resize all to slider</button>
        </div>
        <small class="stat">Controls scale of newly added fish (5–80% of source image). Use “Resize all” to apply to existing fish.</small>
      </div>

      <div class="group" style="min-width:280px">
        <label>Feeding (click tank to drop food)</label>
        <div class="row">
          <label class="row" style="gap:6px"><input type="checkbox" id="feedingToggle"/> Enable feeding</label>
          <button id="clearFood">Clear food</button>
        </div>
        <label>Food size <span id="foodSizeOut" class="stat"></span></label>
        <input id="foodSize" type="range" min="2" max="9" value="5" />
        <label class="row" style="gap:6px; margin-top:6px"><input type="checkbox" id="mandatoryFeeding"/> Mandatory Feeding</label>
        <label class="row" style="gap:6px"><input type="checkbox" id="showHunger"/> Show hunger meters</label>
        <small class="stat">Mandatory Feeding: hungry → green → (1m) dead (BW, floats) → (1m) skeleton → (2m) removed.</small>
      </div>

    </div>

    <div id="stage">
      <canvas id="bg"></canvas>
      <canvas id="fish"></canvas>
      <div class="hud">
        <span class="pill">Fish: <strong id="count">0</strong>/20</span>
        <span class="pill">Food: <strong id="foodCount">0</strong></span>
        <span class="pill">FPS: <strong id="fps">…</strong></span>
        <span class="pill">Tip: paste an IPFS/HTTP image or NFT IDs above. Backgrounds are auto-removed.</span>
      </div>
    </div>
  </div>

  <button id="menuFab" title="Show Menu">☰ Menu</button>

<script>
(function(){
  // ======= UI ELEMENTS =======
  const el = id => document.getElementById(id);
  const panelEl = el('panel');
  const toggleMenuBtn = el('toggleMenu');
  const menuFab = el('menuFab');
  const fsBtn = el('fsBtn');

  const contractEl = el('contract');
  const idsEl = el('ids');
  const addByIdsBtn = el('addByIds');
  const addByUrlBtn = el('addByUrl');
  const imgUrlEl = el('imgUrl');
  const clearBtn = el('clear');
  const fileInput = el('fileInput');
  const useProxy = el('useProxy');
  const stageEl = document.getElementById('stage');
  const pauseBtn = el('pause');
  const staticToggle = el('staticToggle');
  const feedingToggle = el('feedingToggle');
  const mandatoryFeedingToggle = el('mandatoryFeeding');
  const showHungerToggle = el('showHunger');
  const clearFoodBtn = el('clearFood');
  const threshEl = el('thresh');
  const pxEl = el('px');
  const spdEl = el('spd');
  const sizeEl = el('size');
  const foodSizeEl = el('foodSize');
  const threshOut = el('threshOut');
  const pxOut = el('pxOut');
  const spdOut = el('spdOut');
  const sizeOut = el('sizeOut');
  const foodSizeOut = el('foodSizeOut');
  const countEl = el('count');
  const foodCountEl = el('foodCount');
  const fpsEl = el('fps');
  const statusEl = el('status');
  const shotBtn = el('shot');
  const runTestsBtn = el('runTests');
  const testOut = el('testOut');

  const bgCanvas = el('bg');
  const fishCanvas = el('fish');
  const bgCtx = bgCanvas.getContext('2d');
  const fishCtx = fishCanvas.getContext('2d');
  fishCtx.imageSmoothingEnabled = false; // keep sprites crisp

  // ======= STATE =======
  const MAX_FISH = 20;
  const TURN_CHANCE = 0.0008; // ~once/20s per fish at 60fps
  let provider;
  const ERC721_ABI = ['function tokenURI(uint256 tokenId) view returns (string)'];

  // Feeding
  let feedingEnabled = false;
  let mandatoryFeeding = false;
  let showHunger = false;
  const foods = []; // {x,y,vy,size,_eaten}

  // Skeleton cache
  let skeletonCanvas = null; let skeletonLoadPromise = null;
  const SKELETON_URL = 'https://www.shutterstock.com/image-vector/fish-skeleton-icon-8-bit-600nw-2248914709.jpg';

  // Dynamically ensure ethers.js is available, with CDN fallbacks
  async function ensureEthers(){
    if(window.ethers) return window.ethers;
    const cdns = [
      'https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js',
      'https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js',
      'https://unpkg.com/ethers@5.7.2/dist/ethers.umd.min.js'
    ];
    for(const src of cdns){
      try{
        await new Promise((res, rej)=>{ const s=document.createElement('script'); s.src=src; s.onload=res; s.onerror=rej; document.head.appendChild(s); });
        if(window.ethers) return window.ethers;
      }catch(e){ /* try next */ }
    }
    throw new Error('Unable to load ethers.js from CDNs. Check your network/ad-blockers.');
  }

  let fishList = [];
  let paused = false;
  let lastTime = performance.now();
  let fpsSmoothed = 60;
  let bgPixelSize = +pxEl.value;

  function setStatus(msg){ statusEl.textContent = msg; }
  function now(){ return performance.now(); }

  function updateFoodCounter(){ foodCountEl.textContent = String(foods.length); }

  // ======= UTILS =======
  const sleep = ms => new Promise(r=>setTimeout(r,ms));
  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
  function lerp(a,b,t){ return a + (b-a)*t; }

  function colorDist2(r1,g1,b1,r2,g2,b2){
    const dr=r1-r2, dg=g1-g2, db=b1-b2; return dr*dr+dg*dg+db*db;
  }

  function resolveIPFS(u){
    if(!u) return u;
    if(u.startsWith('ipfs://ipfs/')) return 'https://ipfs.io/'+u.slice('ipfs://'.length);
    if(u.startsWith('ipfs://')) return 'https://ipfs.io/ipfs/'+u.slice('ipfs://'.length);
    return u;
  }

  async function fetchImageUrlFromToken(contract, tokenId){
    const c = new ethers.Contract(contract, ERC721_ABI, provider);
    let uri = await c.tokenURI(tokenId);
    if(uri.startsWith('data:application/json')){
      const base = uri.split(',')[1];
      const json = JSON.parse(atob(base));
      return resolveIPFS(json.image || json.image_url || json.imageUrl);
    } else {
      const metaUrl = resolveIPFS(uri);
      const res = await fetch(metaUrl, {mode:'cors'});
      const meta = await res.json();
      return resolveIPFS(meta.image || meta.image_url || meta.imageUrl);
    }
  }

  function sampleBorderColor(imgData){
    const {data, width, height} = imgData;
    const step = Math.max(1, Math.floor(Math.min(width,height)/50));
    const map = new Map();
    function pushPixel(x,y){
      const i = (y*width + x)*4; const r=data[i], g=data[i+1], b=data[i+2];
      const key = ((r>>3)<<10)|((g>>3)<<5)|(b>>3);
      map.set(key, (map.get(key)||0)+1);
    }
    for(let x=0;x<width;x+=step){ pushPixel(x,0); pushPixel(x,height-1); }
    for(let y=0;y<height;y+=step){ pushPixel(0,y); pushPixel(width-1,y); }
    let bestKey=0, bestCount=-1;
    for(const [k,v] of map){ if(v>bestCount){ bestKey=k; bestCount=v; } }
    const r = ((bestKey>>10)&31)<<3;
    const g = ((bestKey>>5)&31)<<3;
    const b = (bestKey&31)<<3;
    return [r,g,b];
  }

  function floodFillAlpha(imgData, targetColor, threshold){
    const {data,width,height} = imgData;
    const thr2 = threshold*threshold;
    const visited = new Uint8Array(width*height);
    const stack = [];
    stack.push(0, (width-1), (height-1)*width, (height-1)*width + (width-1));
    while(stack.length){
      const idx = stack.pop();
      if(visited[idx]) continue; visited[idx]=1;
      const x = idx % width; const y = (idx/width)|0;
      const i = idx*4;
      const r=data[i], g=data[i+1], b=data[i+2];
      if(colorDist2(r,g,b, targetColor[0], targetColor[1], targetColor[2]) <= thr2){
        data[i+3] = 0;
        if(x>0) stack.push(idx-1);
        if(x<width-1) stack.push(idx+1);
        if(y>0) stack.push(idx-width);
        if(y<height-1) stack.push(idx+width);
      }
    }
    for(let y=1;y<height-1;y++){
      for(let x=1;x<width-1;x++){
        const i=(y*width+x)*4;
        if(data[i+3]===0) continue;
        let tn=0; const n=[i-4, i+4, i-4*width, i+4*width];
        for(const j of n){ if(data[j+3]===0) tn++; }
        if(tn>=2){ data[i+3]=Math.min(data[i+3], 180); }
      }
    }
  }

  async function loadImageAsCanvas(url){
    return new Promise((resolve, reject)=>{
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = ()=>{
        const c=document.createElement('canvas'); c.width=img.naturalWidth; c.height=img.naturalHeight;
        const cx=c.getContext('2d'); cx.imageSmoothingEnabled=false; cx.drawImage(img,0,0);
        resolve(c);
      };
      img.onerror = ()=>reject(new Error('Failed to load image (CORS or 404): '+url));
      img.src = resolveIPFS(url);
    });
  }

  async function loadAndChromaKey(url, threshold){
    const c = await loadImageAsCanvas(url);
    const ctx=c.getContext('2d');
    const imgData = ctx.getImageData(0,0,c.width,c.height);
    const bgCol = sampleBorderColor(imgData);
    floodFillAlpha(imgData, bgCol, threshold);
    ctx.putImageData(imgData,0,0);
    return c;
  }

  function weservProxy(url){
    try{
      const u = new URL(url);
      const base = (u.protocol==='https:'?'ssl:':'') + u.host + u.pathname + u.search;
      return 'https://images.weserv.nl/?url=' + base + '&n=-1';
    }catch(e){
      return 'https://images.weserv.nl/?url=' + encodeURIComponent(url) + '&n=-1';
    }
  }
  function proxyUrls(url){
    const a = weservProxy(url);
    return [a, a.replace('images.weserv.nl','wsrv.nl')];
  }
  async function tryLoadFishCanvas(url){
    try{ return await loadAndChromaKey(url, +threshEl.value); }
    catch(e){
      if(useProxy && useProxy.checked && /^https?:/i.test(url)){
        for(const p of proxyUrls(url)){
          try{ return await loadAndChromaKey(p, +threshEl.value); }catch(_){ }
        }
      }
      throw e;
    }
  }

  async function getSkeleton(){
    if(skeletonCanvas) return skeletonCanvas;
    if(skeletonLoadPromise) return skeletonLoadPromise;
    const url = weservProxy(SKELETON_URL);
    skeletonLoadPromise = tryLoadFishCanvas(url).then(c=>{ skeletonCanvas=c; return c; }).catch(err=>{
      console.warn('Skeleton load failed, using fallback', err);
      const c=document.createElement('canvas'); c.width=24; c.height=12; const cx=c.getContext('2d');
      cx.fillStyle='#ffffff'; cx.fillRect(0,5,24,2); cx.fillRect(3,3,2,6); cx.fillRect(8,3,2,6); cx.fillRect(13,3,2,6); cx.fillRect(18,3,2,6);
      skeletonCanvas=c; return c;
    });
    return skeletonLoadPromise;
  }

  // ======= SIZE HELPERS =======
  function getScale(){ return (+sizeEl.value)/100; }
  function resizeAllToScale(scale){
    for(const f of fishList){
      f.w = f.sprite.width * scale;
      f.h = f.sprite.height * scale;
      if(f.x+f.w>fishCanvas.width) f.x = Math.max(0, fishCanvas.width - f.w);
      if(f.y+f.h>fishCanvas.height) f.y = Math.max(0, fishCanvas.height - f.h);
    }
  }

  // ======= ASSIGNMENT (foods → unique nearest fishes) =======
  function assignFoodsToFishes(fishes, foods){
    const chasers = fishes.map((f,i)=>({f,i})).filter(o=>o.f.stage<3); // stage 3+ ignore food
    const pairs = [];
    for(let i=0;i<foods.length;i++){
      const fs = foods[i].size || 1;
      const fx = foods[i].x + fs/2, fy=foods[i].y + fs/2;
      for(const {f,i:iFish} of chasers){
        const cx = f.x + f.w/2, cy = f.y + f.h/2;
        const dx = fx - cx, dy = fy - cy;
        const d2 = dx*dx + dy*dy;
        pairs.push({iFood:i, iFish, d2});
      }
    }
    pairs.sort((a,b)=>a.d2-b.d2);
    const takenF = new Set();
    const takenC = new Set();
    const map = new Map();
    for(const p of pairs){
      if(takenF.has(p.iFood) || takenC.has(p.iFish)) continue;
      takenF.add(p.iFood); takenC.add(p.iFish); map.set(p.iFish, p.iFood);
      if(takenF.size===foods.length || takenC.size===chasers.length) break;
    }
    return map;
  }

  // ======= TINT HELPER (no bleed) =======
  function makeTintOverlay(sprite, width, height, rgba){
    const c=document.createElement('canvas'); c.width=width|0; c.height=height|0; const ctx=c.getContext('2d');
    ctx.imageSmoothingEnabled=false;
    ctx.drawImage(sprite,0,0,width|0,height|0);
    ctx.globalCompositeOperation='source-atop';
    ctx.fillStyle=rgba; ctx.fillRect(0,0,c.width,c.height);
    ctx.globalCompositeOperation='source-over';
    return c;
  }

  // ======= HUNGER METER =======
  function hungerProgress(f){
    if(!mandatoryFeeding) return 0;
    const t=now();
    if(f.stage===1){ return clamp((t - f.lastFedAt)/Math.max(1,f.nextStage2At - f.lastFedAt), 0, 1); }
    if(f.stage===2){ return clamp((t - f.stage2StartAt)/60_000, 0, 1); }
    return 1;
  }

  function drawHungerMeter(ctx,f){
    if(!showHunger || f.stage>=3) return;
    const prog = hungerProgress(f);
    const w = Math.max(20, Math.min(40, f.w*0.6));
    const h = 3;
    let x = (f.x|0) + ((f.w - w)/2)|0;
    let y = (f.y|0) - h - 2; if(y<1) y=1;
    ctx.fillStyle='rgba(0,0,0,0.45)'; ctx.fillRect(x,y,w,h);
    const ww = (w*prog)|0;
    const r = prog<0.5 ? 64 : Math.floor(lerp(64,255,(prog-0.5)/0.5));
    const g = prog<0.5 ? Math.floor(lerp(255,200,prog/0.5)) : Math.floor(lerp(200,80,(prog-0.5)/0.5));
    const b = 80;
    ctx.fillStyle = `rgb(${r},${g},${b})`;
    ctx.fillRect(x,y,ww,h);
    ctx.strokeStyle='rgba(255,255,255,0.25)'; ctx.lineWidth=1; ctx.strokeRect(x+0.5,y+0.5,w-1,h-1);
  }

  // ======= FULLSCREEN HELPERS =======
  function fsElement(){
    return document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
  }
  function isFullscreen(){ return !!fsElement(); }
  function setFsBtnLabel(exiting){ fsBtn.textContent = exiting ? 'Exit Fullscreen' : 'Fullscreen'; }
  function updateFsUI(){ setFsBtnLabel(isFullscreen()); }
  async function enterFullscreen(){
    try{
      if(stageEl.requestFullscreen){ await stageEl.requestFullscreen({ navigationUI: 'hide' }); }
      else if(stageEl.webkitRequestFullscreen){ stageEl.webkitRequestFullscreen(); }
      else if(stageEl.msRequestFullscreen){ stageEl.msRequestFullscreen(); }
    }catch(e){ console.warn('Fullscreen request failed', e); }
  }
  async function exitFullscreen(){
    try{
      if(document.exitFullscreen){ await document.exitFullscreen(); }
      else if(document.webkitExitFullscreen){ document.webkitExitFullscreen(); }
      else if(document.msExitFullscreen){ document.msExitFullscreen(); }
    }catch(e){ console.warn('Exit fullscreen failed', e); }
  }
  function toggleFullscreen(){ if(isFullscreen()) exitFullscreen(); else enterFullscreen(); }

  // ======= FISH ENGINE =======
  class Fish {
    constructor(spriteCanvas, opts={}){
      this.sprite = spriteCanvas;
      const scale = opts.scale || getScale();
      this.w = spriteCanvas.width * scale;
      this.h = spriteCanvas.height * scale;
      this.x = Math.random()*(fishCanvas.width - this.w);
      this.y = Math.random()*(fishCanvas.height - this.h);
      this.baseSpeed = (opts.speed || +spdEl.value) / 60;
      const dir = Math.random()<0.5?-1:1;
      this.vx = dir * (this.baseSpeed*(0.7+Math.random()*0.6));
      this.vy = (Math.random()*2-1) * this.baseSpeed*0.5;
      this.phase = Math.random()*Math.PI*2;
      this.flip = this.vx<0;
      this.wobble = 12 + Math.random()*28;

      // Feeding state
      this.stage = 1; // 1 normal, 2 hungry (green), 3 dead (BW float), 4 skeleton
      this.lastFedAt = now();
      this.stage2StartAt = null;
      this.nextStage2At = this.lastFedAt + (60_000 + Math.random()*240_000); // 1–5 min
      this.stage3StartAt = null; // time dead started
      this.stage4StartAt = null; // time skeleton started
      this.removeAt = null;
    }

    async enterStage3(){
      if(this.stage>=3) return;
      this.stage = 3; // dead fish (BW) floats up for ~1m
      this.stage3StartAt = now();
      this.vx = 0.15 * (Math.random()<0.5?-1:1);
      this.vy = -0.25; // rise
    }

    async enterStage4(){
      if(this.stage>=4) return;
      this.stage = 4; // skeleton
      this.stage4StartAt = now();
      try{ const sk = await getSkeleton(); this.sprite = sk; }catch(e){ }
      this.vx = 0.1 * (Math.random()<0.5?-1:1);
      this.vy = -0.12; // gentle rise, will clamp at surface
      this.removeAt = this.stage4StartAt + 120_000; // remove after 2m
    }

    feed(){
      if(this.stage>=3) return; // dead cannot be fed
      this.stage = 1;
      this.lastFedAt = now();
      this.stage2StartAt = null;
      this.nextStage2At = this.lastFedAt + (60_000 + Math.random()*240_000);
      this.stage3StartAt = null; this.stage4StartAt = null; this.removeAt=null;
    }

    update(dt, assignedFood){
      if(staticToggle.checked) return;
      const px = dt/16.67;

      // stage progression
      if(mandatoryFeeding){
        const t = now();
        if(this.stage===1 && t >= this.nextStage2At){ this.stage=2; this.stage2StartAt = t; }
        else if(this.stage===2 && t - this.stage2StartAt >= 60_000){ this.enterStage3(); }
        else if(this.stage===3 && t - this.stage3StartAt >= 60_000){ this.enterStage4(); }
        if(this.stage===4 && this.removeAt && t >= this.removeAt){ this._remove = true; }
      }

      // physics per stage
      if(this.stage===4){
        this.y += this.vy * px; this.x += this.vx * px; this.phase += 0.01*px; // idle drift
        if(this.y <= 0){ this.y = 0; this.vy = Math.sin(this.phase)*0.03; }
        if(this.x<=0){ this.x=0; this.vx=Math.abs(this.vx); }
        if(this.x+this.w>=fishCanvas.width){ this.x=fishCanvas.width-this.w; this.vx=-Math.abs(this.vx); }
        return;
      }
      if(this.stage===3){
        this.y += this.vy * px; this.x += this.vx * px;
        if(this.y <= 0){ this.y = 0; this.vy = Math.sin(this.phase+=0.01)*0.04; }
        if(this.x<=0){ this.x=0; this.vx=Math.abs(this.vx); }
        if(this.x+this.w>=fishCanvas.width){ this.x=fishCanvas.width-this.w; this.vx=-Math.abs(this.vx); }
        return;
      }

      if(feedingEnabled && assignedFood){
        // Move toward assigned food center
        const fs = assignedFood.size || 1;
        const fx = assignedFood.x + fs/2; const fy = assignedFood.y + fs/2;
        const cx = this.x + this.w/2, cy = this.y + this.h/2;
        const dx = fx - cx; const dy = fy - cy;
        const len = Math.max(0.0001, Math.hypot(dx,dy));
        const step = this.baseSpeed*1.2 * px; // a bit faster when hungry
        // Smoothly align velocity with pursuit direction so facing stays consistent after feeding
        const targetVx = (dx/len) * this.baseSpeed*0.9;
        this.vx = lerp(this.vx, targetVx, 0.15*px);
        this.x += (dx/len) * step;
        this.y += (dy/len) * step;
        // face actual horizontal velocity when significant, else fall back to target direction
        if(Math.abs(this.vx) > 0.001) this.flip = this.vx < 0; else this.flip = dx < 0;
        // consume if food touches fish center
        const eatRadius = Math.max(1.5, fs*0.6);
        if(len < eatRadius){ assignedFood._eaten = true; this.feed(); }
      }else{
        // Normal roaming with gentle sine wobble
        this.phase += 0.03*px;
        this.y += Math.sin(this.phase)*0.4*px + this.vy*px;
        this.x += this.vx*px;
        // occasional random direction flip (rare)
        if(Math.random() < TURN_CHANCE * px){ this.vx = -this.vx; }
        // bounds
        if(this.x<=0){ this.x=0; this.vx=Math.abs(this.vx); }
        if(this.x+this.w>=fishCanvas.width){ this.x=fishCanvas.width-this.w; this.vx=-Math.abs(this.vx); }
        if(this.y<=0){ this.y=0; this.vy=Math.abs(this.vy); }
        if(this.y+this.h>=fishCanvas.height){ this.y=fishCanvas.height-this.h; this.vy=-Math.abs(this.vy); }
        // occasional vertical drift change
        if(Math.random()<0.01){ this.vy += (Math.random()*0.6-0.3); this.vy=clamp(this.vy,-2,2); }
        // Always face direction of travel while roaming
        if(Math.abs(this.vx) > 0.001) this.flip = this.vx < 0;
      }
    }

    draw(ctx){
      ctx.save();
      if(this.stage===4){
        // skeleton upside-down at surface
        ctx.translate((this.x|0), (this.y|0)+this.h);
        ctx.scale(1,-1);
        ctx.drawImage(this.sprite, 0, 0, this.w|0, this.h|0);
        ctx.restore();
        return;
      }
      if(this.stage===3){
        // upside-down grayscale
        ctx.translate((this.x|0), (this.y|0)+this.h);
        ctx.scale(1,-1);
        ctx.filter = 'grayscale(100%)';
        ctx.drawImage(this.sprite, 0, 0, this.w|0, this.h|0);
        ctx.filter = 'none';
        ctx.restore();
        return;
      }
      // stage 1/2 draw facing
      ctx.translate((this.x|0)+(this.flip?this.w:0), (this.y|0));
      ctx.scale(this.flip?-1:1, 1);
      ctx.drawImage(this.sprite, 0, 0, this.w|0, this.h|0);
      if(this.stage===2){
        const tint = makeTintOverlay(this.sprite, this.w|0, this.h|0, 'rgba(0,255,120,0.35)');
        ctx.drawImage(tint, 0, 0);
      }
      ctx.restore();
      drawHungerMeter(ctx, this);
    }
  }

  function resize(){
    const rect = document.getElementById('stage').getBoundingClientRect();
    [bgCanvas, fishCanvas].forEach(c=>{ c.width = rect.width|0; c.height = rect.height|0; });
    drawBackground();
  }

  function drawBackground(){
    const w=bgCanvas.width, h=bgCanvas.height;
    const px=bgPixelSize;
    bgCtx.imageSmoothingEnabled = false;
    for(let y=0;y<h;y+=px){
      for(let x=0;x<w;x+=px){
        const t = (y/h);
        const r = 10 + (10*t)|0;
        const g = 20 + (35*t)|0;
        const b = 60 + (140*t)|0;
        bgCtx.fillStyle = `rgb(${r},${g},${b})`;
        bgCtx.fillRect(x,y,px,px);
      }
    }
    const plants = Math.max(4, (w/260)|0);
    for(let i=0;i<plants;i++){
      const baseX = (i+0.3)*(w/plants) + (Math.random()*30-15);
      let y=h-px*2; let height = h*(0.25+Math.random()*0.25);
      const color = `rgb(${20+Math.random()*20|0}, ${120+Math.random()*60|0}, ${60+Math.random()*40|0})`;
      for(let j=0;j<height;j+=px){
        const spread = Math.sin(j*0.05 + i)*px*0.7;
        bgCtx.fillStyle=color;
        bgCtx.fillRect((baseX+spread)|0, (y-j)|0, px, px);
      }
    }
    const bubbles = (w*h)/(12000);
    bgCtx.fillStyle='rgba(255,255,255,0.5)';
    for(let i=0;i<bubbles;i++){
      const x = (Math.random()*w)|0; const y=(Math.random()*h)|0;
      bgCtx.fillRect(x,y,px,px);
    }
  }

  function render(nowTs){
    const dt = nowTs - lastTime; lastTime = nowTs;
    const fps = 1000/Math.max(1,dt); fpsSmoothed = fpsSmoothed*0.92 + fps*0.08; fpsEl.textContent = fpsSmoothed.toFixed(0);

    if(!paused){
      for(const food of foods){
        const fs = food.size || 1;
        food.vy = 1.0;
        food.y += food.vy * (dt/16.67);
        const bottom = fishCanvas.height - fs;
        if(food.y > bottom) food.y = bottom;
      }
      const assignment = feedingEnabled && foods.length? assignFoodsToFishes(fishList, foods) : new Map();

      fishCtx.clearRect(0,0,fishCanvas.width, fishCanvas.height);
      for(const food of foods){
        const fs = food.size || 1; const x=food.x|0, y=food.y|0;
        fishCtx.fillStyle = 'rgb(30,20,10)'; fishCtx.fillRect(x, y, fs, fs);
        if(fs>=3){ fishCtx.fillStyle = 'rgb(90,70,50)'; fishCtx.fillRect(x+1, y+1, fs-2, fs-2); }
      }
      for(let i=0;i<fishList.length;i++){
        const f = fishList[i];
        const food = assignment.has(i)? foods[assignment.get(i)] : null;
        f.update(dt, food);
        f.draw(fishCtx);
      }
      for(let i=foods.length-1;i>=0;i--){ if(foods[i]._eaten){ foods.splice(i,1); } }
      for(let i=fishList.length-1;i>=0;i--){ if(fishList[i]._remove){ fishList.splice(i,1); } }
      updateFoodCounter();
      countEl.textContent = String(fishList.length);
    }
    requestAnimationFrame(render);
  }

  function addFishFromCanvas(canvas, opts={}){
    if(fishList.length>=MAX_FISH){ alert('Max 20 fish.'); return; }
    fishList.push(new Fish(canvas, {speed:+spdEl.value, scale: opts.scale || getScale()}));
    countEl.textContent = String(fishList.length);
    setStatus('ready');
  }

  async function addFishFromUrl(url){
    if(fishList.length>=MAX_FISH){ alert('Max 20 fish.'); return; }
    setStatus('loading image…');
    try{
      const canvas = await tryLoadFishCanvas(url);
      addFishFromCanvas(canvas);
    }catch(e){
      setStatus('error');
      const msg = (e && e.message) || String(e);
      alert('Could not load image URL.\n\n' + msg + '\n\nFixes:\n• Toggle “Auto CORS fix for URLs”.\n• Use an IPFS gateway that allows CORS (ipfs.io).\n• Or use “Local image file” or drag & drop a PNG.');
    }
  }

  async function addByTokenIds(){
    if(!window.ethers || !provider){ alert('On-chain lookups unavailable (ethers.js not loaded). Paste image URLs instead.'); return; }
    const contract = contractEl.value.trim();
    let ids = idsEl.value.split(/[^0-9]+/).filter(Boolean).map(s=>Number(s));
    if(ids.length===0){ alert('Enter at least one numeric token ID.'); return; }
    if(fishList.length + ids.length > MAX_FISH){ ids = ids.slice(0, MAX_FISH - fishList.length); }
    setStatus('resolving tokenURIs…');
    for(const id of ids){
      try{
        const imgUrl = await fetchImageUrlFromToken(contract, id);
        await addFishFromUrl(imgUrl);
        await sleep(60);
      }catch(e){ console.warn('Failed token', id, e); }
    }
    setStatus('ready');
  }

  // ======= FILE/DRAG & DROP HELPERS =======
  async function addFishFromFile(file){
    if(fishList.length>=MAX_FISH){ return; }
    setStatus('processing file…');
    try{
      const bmp = await createImageBitmap(file);
      const c = document.createElement('canvas'); c.width=bmp.width; c.height=bmp.height;
      const ctx=c.getContext('2d'); ctx.imageSmoothingEnabled=false; ctx.drawImage(bmp,0,0);
      const imgData = ctx.getImageData(0,0,c.width,c.height);
      const bgCol = sampleBorderColor(imgData);
      floodFillAlpha(imgData, bgCol, +threshEl.value);
      ctx.putImageData(imgData,0,0);
      addFishFromCanvas(c);
    }catch(e){ console.warn(e); setStatus('error'); alert('Could not process file: '+((e&&e.message)||e)); }
  }
  async function handleFiles(files){
    for(const file of files){ if(!file.type || !file.type.startsWith('image/')) continue; await addFishFromFile(file); if(fishList.length>=MAX_FISH) break; }
  }

  // ======= TESTS =======
  async function runTests(){
    const logs=[]; let pass=0, fail=0;
    function ok(cond, msg){ if(cond){ pass++; logs.push('✔ '+msg); } else { fail++; logs.push('✘ '+msg); } }
    try{
      ok(resolveIPFS('ipfs://foo')==='https://ipfs.io/ipfs/foo', 'resolveIPFS ipfs://');
      ok(resolveIPFS('ipfs://ipfs/foo')==='https://ipfs.io/foo', 'resolveIPFS ipfs://ipfs/');
      ok(colorDist2(0,0,0,0,0,0)===0, 'colorDist2 zero');

      // Chroma key unit
      const t=document.createElement('canvas'); t.width=4; t.height=4; const tx=t.getContext('2d');
      tx.fillStyle='#00ff00'; tx.fillRect(0,0,4,4);
      tx.fillStyle='#ff0000'; tx.fillRect(1,1,2,2);
      const dataURL=t.toDataURL('image/png');
      const c1 = await loadAndChromaKey(dataURL, 40);
      const ctx1=c1.getContext('2d');
      const img1=ctx1.getImageData(0,0,4,4).data;
      ok(img1[3]===0, 'chroma key clears border');
      ok(img1[((2*4)+2)*4+3]>0, 'chroma key keeps center');

      // Size control
      const s=document.createElement('canvas'); s.width=100; s.height=50; s.getContext('2d').fillRect(0,0,1,1);
      sizeEl.value = 50; const prevCount=fishList.length; addFishFromCanvas(s, {scale: getScale()});
      ok(fishList.length===prevCount+1, 'addFishFromCanvas adds one');
      const f0=fishList[fishList.length-1]; ok(Math.abs(f0.w - 50) < 0.001 && Math.abs(f0.h - 25) < 0.001, 'fish scales to slider');

      // Targeting: two foods → two nearest fishes; skeletons ignored (stage 4)
      const testFishes=[{x:0,y:0,w:10,h:10,stage:4},{x:50,y:0,w:10,h:10,stage:1}];
      const testFoods=[{x:55,y:5,size:5}];
      const m=assignFoodsToFishes(testFishes,testFoods);
      ok(m.size===1 && m.has(1), 'stage 4 ignored in targeting');

      // Tint overlay mask test (no bleed)
      const spr=document.createElement('canvas'); spr.width=8; spr.height=8; const sc=spr.getContext('2d');
      sc.clearRect(0,0,8,8); sc.fillStyle='#ffffff'; sc.fillRect(1,1,6,6);
      const tint=makeTintOverlay(spr,8,8,'rgba(0,255,0,0.5)');
      const td=tint.getContext('2d').getImageData(0,0,8,8).data;
      ok(td[3]===0, 'tint transparent at (0,0)');
      ok(td[((3*8)+3)*4+3]>0, 'tint has alpha inside sprite');

      // Stage transitions: 1 → 2 → 3 → 4 under time pressure
      const ff = f0; mandatoryFeeding = true;
      ff.nextStage2At = performance.now() - 1; ff.update(16, null); ok(ff.stage===2, 'enters stage 2');
      ff.stage2StartAt = performance.now() - 60_100; ff.update(16, null); ok(ff.stage===3, 'enters stage 3 (dead float)');
      ff.stage3StartAt = performance.now() - 60_100; ff.update(16, null); ok(ff.stage===4, 'enters stage 4 (skeleton)');

      // feed() only works while alive
      const fAlive=new Fish(s, {scale:0.5}); fAlive.stage=2; fAlive.stage2StartAt=performance.now(); fAlive.feed(); ok(fAlive.stage===1, 'feed() resets stage to 1 when alive');
      const fDead=new Fish(s, {scale:0.5}); fDead.stage=3; fDead.feed(); ok(fDead.stage===3, 'feed() ignored when dead');

      // Fullscreen UI label (mocked)
      ok(!!fsBtn, 'fullscreen button exists');
      setFsBtnLabel(true); ok(fsBtn.textContent==='Exit Fullscreen', 'fs label set to exit');
      setFsBtnLabel(false); ok(fsBtn.textContent==='Fullscreen', 'fs label set to fullscreen');

      // Facing matches movement when roaming
      const fFacing = new Fish(s, {scale:0.5}); fFacing.vx = 1; fFacing.vy = 0; fFacing.update(16, null); ok(fFacing.flip===false, 'roaming facing right when vx>0');
      fFacing.vx = -1; fFacing.update(16, null); ok(fFacing.flip===true, 'roaming facing left when vx<0');

      // Facing matches pursuit direction when feeding
      const fFeedFace = new Fish(s, {scale:0.5});
      feedingEnabled = true; const foodL = {x:-10, y:fFeedFace.y, size:5}; fFeedFace.update(16, foodL); ok(fFeedFace.flip===true, 'feeding facing left toward food');
      feedingEnabled = false;

      // Random turn flips direction and facing (force trigger)
      const rnd = Math.random; Math.random = ()=>0; const before = fFacing.vx; fFacing.update(16, null); Math.random = rnd;
      ok(fFacing.vx !== before && fFacing.flip === (fFacing.vx<0), 'random turn toggles vx and facing');

      try{ await ensureEthers(); ok(!!window.ethers, 'ensureEthers loads or already present'); }catch{ ok(true, 'ensureEthers soft fail allowed'); }
    }catch(e){ logs.push('Test exception: '+(e&&e.message||e)); fail++; }

    testOut.textContent = `Tests: ${pass} passed, ${fail} failed\n`+logs.join('\n');
  }

  // ======= MENU & FULLSCREEN EVENTS =======
  let menuVisible = true;
  function setMenuVisible(v){
    menuVisible = v; panelEl.style.display = v ? '' : 'none'; menuFab.style.display = v ? 'none' : 'block'; toggleMenuBtn.textContent = v ? 'Hide Menu' : 'Show Menu';
  }

  window.addEventListener('resize', ()=>{ resize(); });
  document.addEventListener('fullscreenchange', ()=>{ updateFsUI(); resize(); });
  document.addEventListener('webkitfullscreenchange', ()=>{ updateFsUI(); resize(); });
  document.addEventListener('msfullscreenchange', ()=>{ updateFsUI(); resize(); });

  pxEl.addEventListener('input', ()=>{ bgPixelSize=+pxEl.value; pxOut.textContent = '('+bgPixelSize+')'; drawBackground(); });
  threshEl.addEventListener('input', ()=>{ threshOut.textContent = '('+threshEl.value+')'; });
  spdEl.addEventListener('input', ()=>{ spdOut.textContent = '('+spdEl.value+')'; });
  sizeEl.addEventListener('input', ()=>{ sizeOut.textContent = '('+sizeEl.value+'%)'; });
  foodSizeEl.addEventListener('input', ()=>{ foodSizeOut.textContent = '('+foodSizeEl.value+' px)'; });

  addByIdsBtn.addEventListener('click', addByTokenIds);
  addByUrlBtn.addEventListener('click', ()=>{ const u=imgUrlEl.value.trim(); if(!u) return alert('Paste an image URL first.'); addFishFromUrl(u); });
  clearBtn.addEventListener('click', ()=>{ fishList.length=0; fishCtx.clearRect(0,0,fishCanvas.width, fishCanvas.height); countEl.textContent=String(fishList.length); });
  pauseBtn.addEventListener('click', ()=>{ paused=!paused; pauseBtn.textContent = paused? 'Resume' : 'Pause'; });
  fileInput.addEventListener('change', ()=>{ handleFiles(fileInput.files); fileInput.value=''; });
  runTestsBtn.addEventListener('click', runTests);
  el('resizeAll').addEventListener('click', ()=>{ resizeAllToScale(getScale()); });

  toggleMenuBtn.addEventListener('click', ()=> setMenuVisible(!menuVisible));
  menuFab.addEventListener('click', ()=> setMenuVisible(true));
  fsBtn.addEventListener('click', toggleFullscreen);
  window.addEventListener('keydown', (e)=>{
    if(e.key==='m' || e.key==='M') setMenuVisible(!menuVisible);
    if(e.key==='f' || e.key==='F') toggleFullscreen();
  });

  // Drag & drop
  stageEl.addEventListener('dragover', (e)=>{ e.preventDefault(); e.dataTransfer.dropEffect='copy'; });
  stageEl.addEventListener('drop', (e)=>{ e.preventDefault(); if(e.dataTransfer && e.dataTransfer.files) handleFiles(e.dataTransfer.files); });

  // Feeding interactions
  feedingToggle.addEventListener('change', ()=>{ feedingEnabled = feedingToggle.checked; });
  mandatoryFeedingToggle.addEventListener('change', ()=>{
    mandatoryFeeding = mandatoryFeedingToggle.checked;
    if(!mandatoryFeeding){ for(const f of fishList){ if(f.stage<3) f.feed(); } }
  });
  showHungerToggle.addEventListener('change', ()=>{ showHunger = showHungerToggle.checked; });
  clearFoodBtn.addEventListener('click', ()=>{ foods.length = 0; updateFoodCounter(); });
  stageEl.addEventListener('click', (e)=>{
    if(!feedingEnabled) return;
    const rect = fishCanvas.getBoundingClientRect();
    const x = e.clientX - rect.left; const y = e.clientY - rect.top; const size = +foodSizeEl.value;
    foods.push({x, y, vy:1, size}); updateFoodCounter();
  });

  // ======= INIT =======
  (async function init(){
    try{ await ensureEthers(); provider = new ethers.providers.JsonRpcProvider('https://cloudflare-eth.com'); setStatus('ready'); }
    catch(e){ console.warn(e); setStatus('ethers.js failed to load. You can still add fish by URL.'); }
    threshOut.textContent = '('+threshEl.value+')'; pxOut.textContent = '('+pxEl.value+')'; spdOut.textContent = '('+spdEl.value+')'; sizeOut.textContent = '('+sizeEl.value+'%)'; foodSizeOut.textContent = '('+foodSizeEl.value+' px)';
    updateFsUI();
    resize(); requestAnimationFrame(render);
  })();
})();
</script>
</body>
</html>

